package ca.frar.jjjrmi.socket;
import ca.frar.jjjrmi.translator.Translator;
import ca.frar.jjjrmi.socket.observer.events.*;
import ca.frar.jjjrmi.socket.observer.*;
import ca.frar.jjjrmi.socket.message.*;
import ca.frar.jjjrmi.translator.EncodedJSON;
import ca.frar.jjjrmi.translator.EncoderException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.websocket.*;
import ca.frar.jjjrmi.translator.HasWebsockets;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
import javax.servlet.ServletContext;
import javax.websocket.server.ServerApplicationConfig;
import javax.websocket.server.ServerEndpointConfig;
import org.json.JSONException;

/**
 * A basic JJJ Socket.  It will have the address ws://host/app-name/socket-name<br>
 * @author edward
 */
public abstract class JJJSocket<T extends HasWebsockets> extends Endpoint implements InvokesMethods, ServerApplicationConfig {
    final static org.apache.logging.log4j.Logger LOGGER = org.apache.logging.log4j.LogManager.getLogger(JJJSocket.class);
    private int nextUID = 0;
    private final MethodBank methodBank = new MethodBank();
    private final HashMap<Session, Translator> sessionTranslators = new HashMap<>();
    private final JJJObserverCollection observers = new JJJObserverCollection();
    private ServletContext context;

    void setContext(ServletContext servletContext) {
        this.context = servletContext;
    }

    protected ServletContext getContext(){
        return context;
    }
    
    private class MsgHandler implements MessageHandler.Whole<String> {
        private final Session session;
        private final JJJSocket<T> socket;
        private 
        
        MsgHandler(JJJSocket<T> socket, Session session) {
            this.session = session;
            this.socket = socket;
        }

        @Override
        public void onMessage(String message) {
            synchronized (socket) {
                LOGGER.debug("JJJSocket.MsgHandler.onMessage()");
                socket.processRequest(session, message);
            }
        }
    }

    public final void addObserver(JJJObserver observer) {
        LOGGER.debug("JJJSocket.addObserver()");
        observers.add(observer);
    }

    public final void clearObservers() {
        LOGGER.debug("JJJSocket.clearObservers()");
        observers.clear();
    }

    public final void removeObserver(JJJObserver observer) {
        LOGGER.debug("JJJSocket.removeObserver()");
        observers.remove(observer);
    }

    @Override
    public final void forget(HasWebsockets forgettable) {
        LOGGER.debug("JJJSocket.forget()");
        for (Session session : this.sessionTranslators.keySet()) {
            try {
                Translator translator = getTranslator(session);
                String key = translator.getReference(forgettable);
                translator.removeByValue(forgettable);
                this.sendObject(session, new ForgetMessage(key));
            } catch (InvalidJJJSessionException ex) {
                Logger.getLogger(JJJSocket.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }

    @SuppressWarnings("UseSpecificCatch")
    private void processRequest(Session session, String message) {
        LOGGER.debug("JJJSocket.processRequest()");
        try {
            synchronized (this) {
                Translator translator = getTranslator(session);
                ClientMessage clientMessage = (ClientMessage) translator.decode(message);

                JJJReceiveEvent rmiReceiveEvent = new JJJReceiveEvent(session, clientMessage, message);
                this.observers.receive(rmiReceiveEvent);
                if (rmiReceiveEvent.isDefaultPrevented()) return;

                switch (clientMessage.getType()) {
                    case METHOD_REQUEST:
                        onMethodRequest(session, (MethodRequest) clientMessage);
                        break;
                }
            }
        } catch (JSONException ex) {
            LOGGER.warn(message);
            Logger.getLogger(JJJSocket.class.getName()).log(Level.SEVERE, null, ex);
            if (ex.getCause() != null) Logger.getLogger(JJJSocket.class.getName()).log(Level.SEVERE, null, ex.getCause());
        } catch (Exception ex) {
            LOGGER.warn(message);
            Logger.getLogger(JJJSocket.class.getName()).log(Level.SEVERE, null, ex);
            if (ex.getCause() != null) Logger.getLogger(JJJSocket.class.getName()).log(Level.SEVERE, null, ex.getCause());
        }
    }

    /**
    This method is called by the server when a client connects.  All of the JJJObservers 'open' methods will be called
    passing in the rmiOpenEvent object generated by this method.  If any observer calls the 'rejectConnection()' method
    on the event then a 'RejectedConnectionMessage' is sent and the session is terminated.  The Websocket will continue
    to listen for more onOpen events.<br>
    If no observer calls the preventDefault method of the JJJOpenEvent then the translator this an encode and
    decode listeners to the translator - which is unique to this session.  Then a ReadyMessage is sent to the client.
    ReadyMessage will contain the result of the abstract intatiateObject method, which must be overridden by the
    implementer and creates the root object that the client will get other objects from.
    @param session
    @param ec
     */
    @Override
    public final void onOpen(Session session, EndpointConfig ec) {
        LOGGER.debug("JJJSocket.onOpen()");
        synchronized (this) {
            Translator translator = new Translator();
            sessionTranslators.put(session, translator);

            JJJOpenEvent rmiOpenEvent = new JJJOpenEvent(session, translator);
            this.observers.open(rmiOpenEvent);

            /* if any of the listeners reject the open event, terminate opening */
            if (rmiOpenEvent.isRejected()) {
                try {
                    this.sendObject(session, new RejectedConnectionMessage());
                    sessionTranslators.remove(session);
                    return;
                } catch (InvalidJJJSessionException ex) {
                    Logger.getLogger(JJJSocket.class.getName()).log(Level.SEVERE, null, ex);
                }
            }

            if (rmiOpenEvent.isDefaultPrevented()) return;

            translator.addDecodeListener((obj) -> {
                if (obj instanceof HasWebsockets) ((HasWebsockets) obj).addWebsocket(this);
            });

            translator.addEncodeListener((obj) -> {
                if (obj instanceof HasWebsockets) ((HasWebsockets) obj).addWebsocket(this);
            });

            session.addMessageHandler(new MsgHandler(this, session));

            try {
                this.sendObject(session, new ReadyMessage<>(retrieveRoot()));
            } catch (InvalidJJJSessionException ex) {
                Logger.getLogger(JJJSocket.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }

    public abstract T retrieveRoot();

    private void sendObject(JJJMessage msg) throws InvalidJJJSessionException {
        LOGGER.debug("JJJSocket.sendObject()");
        for (Session session : sessionTranslators.keySet()) {
            this.sendObject(session, msg);
        }
    }

    private Translator getTranslator(Session session) throws InvalidJJJSessionException {
        LOGGER.debug("JJJSocket.getTranslator()");
        Translator translator = this.sessionTranslators.get(session);

        if (translator == null) {
            InvalidJJJSessionException invalidJJJSessionException = new InvalidJJJSessionException();
            handleException(session, invalidJJJSessionException, null);
            throw invalidJJJSessionException;
        }

        return translator;
    }

    /**
     * Encode an object as a JJJ string and send it to the client.
     * @param obj
     */
    private final void sendObject(Session session, JJJMessage msg) throws InvalidJJJSessionException {
        LOGGER.debug("JJJSocket.sendObject()");
        JJJSendEvent<?> rmiSendEvent = new JJJSendEvent<>(session, msg);
        this.observers.send(rmiSendEvent);
        if (rmiSendEvent.isDefaultPrevented()) return;
        Translator translator = getTranslator(session);

        synchronized (this) {
            try {
                LOGGER.info(msg.getClass().getSimpleName());
                EncodedJSON encoded = translator.encode(msg);
                String exAsString = encoded.toString();
                session.getBasicRemote().sendText(exAsString);
                
                JJJSentEvent<?> rmiSentEvent = new JJJSentEvent<>(session, msg, encoded);
                this.observers.sent(rmiSentEvent);
            } catch (IOException | IllegalStateException ex) {
                /* can be caused by the user refreshing the browser while a message is being processed */
                LOGGER.warn(this.getClass().getSimpleName() + " IllegalStateException");
                LOGGER.warn(ex.getMessage());
                try {
                    Thread.sleep(2000);
                    LOGGER.warn(this.getClass().getSimpleName() + " IllegalStateException : resume");
                } catch (InterruptedException ex1) {
                    Logger.getLogger(JJJSocket.class.getName()).log(Level.SEVERE, null, ex1);
                }
            } catch (IllegalArgumentException | IllegalAccessException ex) {
                LOGGER.warn(ex.getClass().getSimpleName());
                LOGGER.warn(ex.getMessage());
                Logger.getLogger(JJJSocket.class.getName()).log(Level.SEVERE, null, ex);
                handleException(ex);
            } catch (EncoderException ex) {
                LOGGER.warn(ex.getClass().getSimpleName());
                LOGGER.warn(ex.getObject().getClass().getSimpleName());
                Logger.getLogger(JJJSocket.class.getName()).log(Level.SEVERE, null, ex);

                if (msg instanceof MethodResponse){
                    handleException(ex, (MethodResponse) msg);
                } else {
                    handleException(ex);
                }
            } catch (Exception ex) {
                Logger.getLogger(JJJSocket.class.getName()).log(Level.SEVERE, null, ex);
                handleException(ex);
            }
        }
    }

    @Override
    public final void invokeClientMethod(Object source, String methodName, Object... args) {
        LOGGER.debug("JJJSocket.invokeClientMethod()");
        for (Session session : this.sessionTranslators.keySet()) {
            Translator translator;
            try {
                translator = getTranslator(session);
                ClientRequestMessage remoteInvocation = new ClientRequestMessage("" + nextUID++, translator.getReference(source), methodName, args);

                JJJMethodInvocationEvent rmiMethodInvocationEvent = new JJJMethodInvocationEvent(session, source, methodName, args);
                this.observers.clientMethodInvocation(rmiMethodInvocationEvent);
                if (rmiMethodInvocationEvent.isDefaultPrevented()) return;
          
                sendObject(session, remoteInvocation);
            } catch (InvalidJJJSessionException ex) {
                Logger.getLogger(JJJSocket.class.getName()).log(Level.SEVERE, null, ex);
                return;
            }
        }
    }

    private final void handleException(Exception ex, MethodResponse methodResponse) {
        LOGGER.debug("JJJSocket.handleException(ex, methodResponse)");
        for (Session session : this.sessionTranslators.keySet()) this.handleException(session, ex, methodResponse);
    }

    public final void handleException(Exception ex) {
        LOGGER.debug("JJJSocket.handleException(ex)");
        for (Session session : this.sessionTranslators.keySet()) this.handleException(session, ex, null);
    }

    private void handleException(Session session, Exception ex, MethodResponse methodResponse) {
        LOGGER.debug("JJJSocket.handleException(seesion, ex, methodResponse)");
        JJJExceptionEvent exceptionEvent = new JJJExceptionEvent(session, ex);
        this.observers.exception(exceptionEvent);
        if (exceptionEvent.isDefaultPrevented()) return;

        Translator translator;
        try {
            translator = getTranslator(session);
        } catch (InvalidJJJSessionException ex1) {
            Logger.getLogger(JJJSocket.class.getName()).log(Level.SEVERE, null, ex1);
            return;
        }

        try {
            ServerSideExceptionMessage serverSideExceptionMessage;

            if (methodResponse != null){
                serverSideExceptionMessage = new ServerSideExceptionMessage(methodResponse.getUid(), methodResponse.getObjectPTR(), methodResponse.getMethodName(), ex);
            } else {
                serverSideExceptionMessage = new ServerSideExceptionMessage(ex);
            }

            String exAsString = translator.encode(serverSideExceptionMessage).toString();
            session.getBasicRemote().sendText(exAsString);
            ex.printStackTrace();
        } catch (IllegalArgumentException | IllegalAccessException | EncoderException | IOException ex1) {
            Logger.getLogger(JJJSocket.class.getName()).log(Level.SEVERE, null, ex1);
        }
    }

    private void onMethodRequest(Session session, MethodRequest request) throws SecurityException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, NoSuchFieldException, IOException, InvalidJJJSessionException {
        LOGGER.debug("JJJSocket.onMethodRequest()");
        Translator translator = getTranslator(session);
        Object object = translator.getReferredObject(request.objectPTR);

        /* object was previously sent by this socket */
        if (object == null) {
            /* should never happen in normal running, indicates a coding/logic problem */
            this.sendObject(new ServerSideExceptionMessage(request.uid, request.objectPTR, request.methodName, "objectNotFound", "Null result from getRefferredObject()."));
            LOGGER.error(request.objectPTR);
            throw new NullPointerException();
        }

        JJJMethodRequestEvent methodRequestEvent = new JJJMethodRequestEvent(session, object, request);
        this.observers.serverMethodRequest(methodRequestEvent);
        if (methodRequestEvent.isDefaultPrevented()) return;        
        
        Method method = methodBank.getMethod(object.getClass(), request.methodName);

        if (method == null) {
            LOGGER.debug("Method '" + request.methodName + "' not found.");
            this.sendObject(new ServerSideExceptionMessage(request.uid, request.objectPTR, request.methodName, "methodNotFound", "Method " + request.methodName + " not found."));
            return;
        }

        try {
            if (method.getParameters().length != request.methodArguments.length){
                throw new RuntimeException("Required and received argument list length does not match");
            }
            request.update(method.getParameters());
            
            Object returnedFromInvoke;
            try{
                 returnedFromInvoke = method.invoke(object, request.methodArguments);
            } catch (InvocationTargetException ex){
                LOGGER.info("JJJ ERROR: failure accessing method '" + request.methodName + "' of object type '" + object.getClass().getSimpleName() + "'");
                if (ex.getCause() != null)  Logger.getLogger(JJJSocket.class.getName()).log(Level.SEVERE, null, ex.getCause());
                throw ex;
            }

            sendObject(session, new MethodResponse(request.uid, request.objectPTR, request.methodName, returnedFromInvoke));
        } catch (java.lang.IllegalArgumentException ex) {
            Logger.getLogger(JJJSocket.class.getName()).log(Level.SEVERE, null, ex);
            if (request.methodArguments.length == 0) {
                LOGGER.warn(object.getClass().getSimpleName() + "." + method.getName() + " could not be invoked with no arguments.");
            } else {
                LOGGER.warn(object.getClass().getSimpleName() + "." + method.getName() + " could not be invoked with the following argument types:");
                for (Object o : request.methodArguments) {
                    if (o != null) LOGGER.warn(": " + o.getClass().getSimpleName());
                    else LOGGER.warn(": null");
                }
            }
            this.sendObject(new ServerSideExceptionMessage(request.uid, request.objectPTR, request.methodName, ex));
        } catch (java.lang.reflect.InvocationTargetException ex) {
            Logger.getLogger(JJJSocket.class.getName()).log(Level.SEVERE, null, ex);
            if (ex.getCause() != null) this.sendObject(new ServerSideExceptionMessage(request.uid, request.objectPTR, request.methodName, ex.getCause()));
            else this.sendObject(new ServerSideExceptionMessage(request.uid, request.objectPTR, request.methodName, ex));
        }
    }

    @Override
    @OnClose
    public final void onClose(Session session, CloseReason cr) {
        LOGGER.debug("JJJSocket.onClose()");
        Translator removedTranslator = this.sessionTranslators.remove(session);
        
        JJJCloseEvent closeEvent = new JJJCloseEvent(session);
        if (removedTranslator != null){
            Collection objRef = removedTranslator.getAllReferredObjects();  
            
            objRef.forEach(obj->{
                if (obj instanceof HasWebsockets) ((HasWebsockets)obj).removeWebsocket(this);                
            });
        }        
        this.observers.close(closeEvent);
        // CLOVER:FLUSH
    }

    @Override
    @OnError
    public final void onError(Session session, Throwable err) {
        LOGGER.debug(String.format("JJJSocket.onError(%s)", err.getMessage()));
        Translator removedTranslator = this.sessionTranslators.remove(session);
        
        JJJExceptionEvent exceptionEvent = new JJJExceptionEvent(session, err);
        this.observers.exception(exceptionEvent);
        
        if (removedTranslator != null){            
            Collection objRef = removedTranslator.getAllReferredObjects();
            objRef.forEach(obj->{
                if (obj instanceof HasWebsockets) ((HasWebsockets)obj).removeWebsocket(this);                
            });
        }        
        // CLOVER:FLUSH
    }

    @Override
    @SuppressWarnings("unchecked")
    public final Set<ServerEndpointConfig> getEndpointConfigs(Set<Class<? extends Endpoint>> set) {
        LOGGER.debug("JJJSocket.getEndpointConfigs()");
        Set<ServerEndpointConfig> retSet = new HashSet<>();
        String endpointName = "/" + this.getClass().getSimpleName();
        ServerEndpointConfig.Builder builder = ServerEndpointConfig.Builder.create(this.getClass(), endpointName);
        builder.configurator(new JJJConfigurator((Class<? extends JJJSocket<?>>) this.getClass()));
        retSet.add(builder.build());
        return retSet;
    }

    @Override
    public final Set<Class<?>> getAnnotatedEndpointClasses(Set<Class<?>> set) {
        LOGGER.debug("JJJSocket.getAnnotatedEndpointClasses()");
        return set;
    }

    public final Collection<Session> getSessions(){
        LOGGER.debug("JJJSocket.getSessions()");
        Set<Session> keySet = this.sessionTranslators.keySet();
        return new ArrayList<>(keySet);
    }
}
